from flask import Flask, request, jsonify, render_template, redirect, url_for
from flask_cors import CORS
from flask_login import LoginManager, login_required, current_user
import asyncio
from telethon.sync import TelegramClient
from telethon.sessions import StringSession
from telethon.errors import SessionPasswordNeededError, FloodWaitError, AuthKeyDuplicatedError
import os
import json
from datetime import datetime, timezone, date
import threading
import time
import hashlib
import fcntl
import atexit
import traceback

# –ò–º–ø–æ—Ä—Ç—ã –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
from models import db, User
from auth import auth_bp, admin_required, operator_required

app = Flask(__name__)
CORS(app)  # –†–∞–∑—Ä–µ—à–∞–µ–º CORS –¥–ª—è –≤—Å–µ—Ö –¥–æ–º–µ–Ω–æ–≤

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Flask
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'your-secret-key-change-in-production')
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:///telegram_dashboard.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–π
db.init_app(app)
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'auth.login'
login_manager.login_message = '–î–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –≤–æ–π—Ç–∏ –≤ —Å–∏—Å—Ç–µ–º—É.'
login_manager.login_message_category = 'info'

@login_manager.user_loader
def load_user(user_id):
    return User.query.get(user_id)

# –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è Blueprint'–æ–≤
app.register_blueprint(auth_bp)

# –í–∞—à–∏ API credentials
api_id = 24914656
api_hash = '126107e0e53e49d94b3d3512d0715198'

OPERATORS_FILE = 'operators.json'
lock = threading.Lock()

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π –ø—É–ª –∫–ª–∏–µ–Ω—Ç–æ–≤ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
clients_pool = {}
clients_lock = threading.Lock()

# –°–ª–æ–≤–∞—Ä—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è phone_code_hash
phone_code_hashes = {}

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π event loop –¥–ª—è asyncio
global_loop = None
loop_thread = None

def setup_global_event_loop():
    """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ event loop –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ"""
    global global_loop, loop_thread
    
    def run_event_loop():
        global global_loop
        global_loop = asyncio.new_event_loop()
        asyncio.set_event_loop(global_loop)
        print("üîÑ –ì–õ–û–ë–ê–õ–¨–ù–´–ô EVENT LOOP –ó–ê–ü–£–©–ï–ù")
        global_loop.run_forever()
    
    if global_loop is None or global_loop.is_closed():
        loop_thread = threading.Thread(target=run_event_loop, daemon=True)
        loop_thread.start()
        time.sleep(0.5)  # –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –∑–∞–ø—É—Å–∫
        print("‚úÖ –ì–õ–û–ë–ê–õ–¨–ù–´–ô EVENT LOOP –ù–ê–°–¢–†–û–ï–ù")

def run_async_in_global_loop(coro):
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç –∫–æ—Ä—É—Ç–∏–Ω—É –≤ –≥–ª–æ–±–∞–ª—å–Ω–æ–º event loop"""
    global global_loop
    if global_loop is None or global_loop.is_closed():
        setup_global_event_loop()
    
    future = asyncio.run_coroutine_threadsafe(coro, global_loop)
    return future.result(timeout=30)  # 30 —Å–µ–∫—É–Ω–¥ —Ç–∞–π–º–∞—É—Ç

def check_operator_access(operator_name):
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∏–º–µ–µ—Ç –ª–∏ —Ç–µ–∫—É—â–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ—Å—Ç—É–ø –∫ –æ–ø–µ—Ä–∞—Ç–æ—Ä—É"""
    if not current_user.is_authenticated:
        return False
    
    # –ê–¥–º–∏–Ω –∏–º–µ–µ—Ç –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞–º
    if current_user.is_admin():
        return True
    
    # –û–ø–µ—Ä–∞—Ç–æ—Ä –∏–º–µ–µ—Ç –¥–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ –∫ —Å–≤–æ–µ–º—É assigned_operator_name
    return current_user.assigned_operator_name == operator_name

def load_operators_safe():
    """–ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤ –∏–∑ —Ñ–∞–π–ª–∞ —Å —Ñ–∞–π–ª–æ–≤–æ–π –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π"""
    with lock:
        try:
            if os.path.exists(OPERATORS_FILE):
                with open(OPERATORS_FILE, 'r', encoding='utf-8') as f:
                    fcntl.flock(f.fileno(), fcntl.LOCK_SH)
                    try:
                        data = json.load(f)
                        return data if isinstance(data, list) else []
                    finally:
                        fcntl.flock(f.fileno(), fcntl.LOCK_UN)
            else:
                return []
        except Exception as e:
            print(f"Error loading operators: {e}")
            return []

def save_operators_safe(operators):
    """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤ –≤ —Ñ–∞–π–ª —Å —Ñ–∞–π–ª–æ–≤–æ–π –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π"""
    with lock:
        try:
            temp_file = OPERATORS_FILE + '.tmp'
            with open(temp_file, 'w', encoding='utf-8') as f:
                fcntl.flock(f.fileno(), fcntl.LOCK_EX)
                try:
                    json.dump(operators, f, ensure_ascii=False, indent=2)
                    f.flush()
                    os.fsync(f.fileno())
                finally:
                    fcntl.flock(f.fileno(), fcntl.LOCK_UN)
            
            os.rename(temp_file, OPERATORS_FILE)
            return True
        except Exception as e:
            print(f"Error saving operators: {e}")
            if os.path.exists(temp_file):
                try:
                    os.remove(temp_file)
                except:
                    pass
            return False

def get_session_name(operator_id, phone_number):
    """–°–æ–∑–¥–∞–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è —Å–µ—Å—Å–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ operator_id –∏ –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞"""
    unique_string = f"{operator_id}_{phone_number}"
    hash_object = hashlib.md5(unique_string.encode())
    return f"session_{hash_object.hexdigest()}"

async def get_or_create_client(operator_id, phone_number):
    """
    –ü–æ–ª—É—á–∞–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–ª–∏–µ–Ω—Ç –∏–∑ –ø—É–ª–∞ –∏–ª–∏ —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π
    """
    client_key = f"{operator_id}_{phone_number}"
    
    with clients_lock:
        if client_key in clients_pool:
            client = clients_pool[client_key]
            if client.is_connected():
                print(f"‚ôªÔ∏è –ò–°–ü–û–õ–¨–ó–£–ï–ú –°–£–©–ï–°–¢–í–£–Æ–©–ò–ô –ö–õ–ò–ï–ù–¢ –¥–ª—è {phone_number}")
                return client
            else:
                print(f"üîÑ –ü–ï–†–ï–ü–û–î–ö–õ–Æ–ß–ê–ï–ú –ö–õ–ò–ï–ù–¢–ê –¥–ª—è {phone_number}")
                try:
                    await client.connect()
                    return client
                except Exception as e:
                    print(f"‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {e}")
                    # –£–¥–∞–ª—è–µ–º –Ω–µ—Ä–∞–±–æ—Ç–∞—é—â–∏–π –∫–ª–∏–µ–Ω—Ç
                    del clients_pool[client_key]
    
    # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –∫–ª–∏–µ–Ω—Ç
    print(f"üÜï –°–û–ó–î–ê–ï–ú –ù–û–í–´–ô –ö–õ–ò–ï–ù–¢ –¥–ª—è {phone_number}")
    
    os.makedirs("sessions", exist_ok=True)
    session_name = get_session_name(operator_id, phone_number)
    session_path = f"sessions/{session_name}"
    
    client = TelegramClient(
        session_path, 
        api_id, 
        api_hash,
        system_version="4.16.30-vxCUSTOM"
    )
    
    try:
        await client.connect()
        print(f"‚úÖ –ö–õ–ò–ï–ù–¢ –ü–û–î–ö–õ–Æ–ß–ï–ù –¥–ª—è {phone_number}")
        
        # –î–æ–±–∞–≤–ª—è–µ–º –≤ –ø—É–ª
        with clients_lock:
            clients_pool[client_key] = client
        
        return client
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–ª–∏–µ–Ω—Ç–∞: {e}")
        try:
            await client.disconnect()
        except:
            pass
        raise e

def cleanup_clients():
    """–û—á–∏—Å—Ç–∫–∞ –∫–ª–∏–µ–Ω—Ç–æ–≤ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–∞–±–æ—Ç—ã"""
    print("üßπ –û–ß–ò–°–¢–ö–ê –ö–õ–ò–ï–ù–¢–û–í...")
    with clients_lock:
        for client_key, client in clients_pool.items():
            try:
                if hasattr(client, 'disconnect'):
                    # –ó–∞–ø—É—Å–∫–∞–µ–º –æ—Ç–∫–ª—é—á–µ–Ω–∏–µ –≤ –≥–ª–æ–±–∞–ª—å–Ω–æ–º event loop
                    if global_loop and not global_loop.is_closed():
                        future = asyncio.run_coroutine_threadsafe(client.disconnect(), global_loop)
                        future.result(timeout=5)
                    print(f"‚úÖ –ö–ª–∏–µ–Ω—Ç {client_key} –æ—Ç–∫–ª—é—á–µ–Ω")
            except Exception as e:
                print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∏—è –∫–ª–∏–µ–Ω—Ç–∞ {client_key}: {e}")
        clients_pool.clear()
    
    # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π event loop
    if global_loop and not global_loop.is_closed():
        global_loop.call_soon_threadsafe(global_loop.stop)
    
    print("‚úÖ –û–ß–ò–°–¢–ö–ê –ó–ê–í–ï–†–®–ï–ù–ê")

# –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é –æ—á–∏—Å—Ç–∫–∏
atexit.register(cleanup_clients)

@app.route('/')
def index():
    """–ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —Å –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –ø–∞–Ω–µ–ª—å"""
    if current_user.is_authenticated:
        if current_user.is_admin():
            return redirect(url_for('auth.admin_dashboard'))
        else:
            return redirect(url_for('auth.operator_dashboard'))
    return redirect(url_for('auth.login'))

# ============= –≠–ù–î–ü–û–ò–ù–¢–´ –ê–í–¢–û–†–ò–ó–ê–¶–ò–ò (–∑–∞—â–∏—â–µ–Ω–Ω—ã–µ) =============

@app.route('/api/auth/send-code', methods=['POST'])
@login_required
def send_code():
    try:
        print("üì• –ü–æ–ª—É—á–µ–Ω –∑–∞–ø—Ä–æ—Å –Ω–∞ –æ—Ç–ø—Ä–∞–≤–∫—É –∫–æ–¥–∞")
        data = request.get_json()
        print(f"üìã –î–∞–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å–∞: {json.dumps(data, indent=2)}")
        
        phone = data.get('phone')
        operator = data.get('operator')
        
        if not phone or not operator:
            print("‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã")
            return jsonify({'success': False, 'error': 'Phone and operator are required'})
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞
        if not check_operator_access(operator):
            return jsonify({'success': False, 'error': '–î–æ—Å—Ç—É–ø –∫ —ç—Ç–æ–º—É –æ–ø–µ—Ä–∞—Ç–æ—Ä—É –∑–∞–ø—Ä–µ—â–µ–Ω'}), 403
        
        print(f"üìû –û–¢–ü–†–ê–í–ö–ê –ö–û–î–ê –¥–ª—è {phone}, –æ–ø–µ—Ä–∞—Ç–æ—Ä: {operator}")
        
        async def send_code_async():
            try:
                print("üîß –ü–æ–ª—É—á–∞–µ–º –∫–ª–∏–µ–Ω—Ç –∏–∑ –ø—É–ª–∞...")
                client = await get_or_create_client(operator, phone)
                
                print(f"üöÄ –û–¢–ü–†–ê–í–õ–Ø–ï–ú –ö–û–î —á–µ—Ä–µ–∑ Telegram API...")
                result = await client.send_code_request(phone)
                phone_code_hash = result.phone_code_hash
                
                print(f"‚úÖ –ö–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω. phone_code_hash: {phone_code_hash[:20]}...")
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º phone_code_hash –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
                phone_code_hashes[f"{operator}_{phone}"] = phone_code_hash
                
                print(f"‚úÖ –ö–û–î –û–¢–ü–†–ê–í–õ–ï–ù –¥–ª—è {phone}")
                return {
                    'success': True, 
                    'message': '–ö–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ Telegram',
                    'phone_code_hash': phone_code_hash
                }
                
            except Exception as e:
                print(f"‚ùå –û–®–ò–ë–ö–ê –û–¢–ü–†–ê–í–ö–ò –ö–û–î–ê: {e}")
                print(f"‚ùå TRACEBACK: {traceback.format_exc()}")
                return {'success': False, 'error': str(e)}
        
        result = run_async_in_global_loop(send_code_async())
        print(f"üéØ –†–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–æ–¥–∞: {json.dumps(result, indent=2)}")
        return jsonify(result)
        
    except Exception as e:
        print(f"üí• –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê –≤ send_code: {str(e)}")
        print(f"üí• TRACEBACK: {traceback.format_exc()}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/auth/verify', methods=['POST'])
@login_required
def verify_code():
    try:
        print("üì• –ü–æ–ª—É—á–µ–Ω –∑–∞–ø—Ä–æ—Å –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É –∫–æ–¥–∞")
        data = request.get_json()
        print(f"üìã –î–∞–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏: {json.dumps(data, indent=2)}")
        
        phone = data.get('phone')
        code = data.get('code')
        phone_code_hash = data.get('phone_code_hash')
        operator = data.get('operator')
        
        if not all([phone, code, phone_code_hash, operator]):
            print("‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏")
            return jsonify({'success': False, 'error': 'All fields are required'})
        
        print(f"üîê –ü–†–û–í–ï–†–ö–ê –ö–û–î–ê {code} –¥–ª—è {phone}")
        
        async def verify_code_async():
            try:
                print("üîß –ü–æ–ª—É—á–∞–µ–º –∫–ª–∏–µ–Ω—Ç –∏–∑ –ø—É–ª–∞...")
                client = await get_or_create_client(operator, phone)
                
                print(f"üöÄ –ü–†–û–í–ï–†–Ø–ï–ú –ö–û–î —á–µ—Ä–µ–∑ Telegram API...")
                print(f"üîê –ü–∞—Ä–∞–º–µ—Ç—Ä—ã: phone={phone}, code={code}, phone_code_hash={phone_code_hash[:20] if phone_code_hash else 'None'}...")
                
                try:
                    user = await client.sign_in(phone, code, phone_code_hash=phone_code_hash)
                    print(f"‚úÖ –ö–û–î –ü–†–ò–ù–Ø–¢ –¥–ª—è {phone}")
                    print(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user.first_name if hasattr(user, 'first_name') else '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}")
                    
                    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Å–µ—Å—Å–∏–∏
                    session_data = client.session.save()
                    print(f"‚úÖ –°–µ—Å—Å–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞, –¥–ª–∏–Ω–∞: {len(session_data) if session_data else 0}")
                    
                    return {
                        'success': True,
                        'message': '–£—Å–ø–µ—à–Ω–∞—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è',
                        'session_data': session_data,
                        'needs_password': False
                    }
                    
                except SessionPasswordNeededError:
                    print(f"üõ°Ô∏è –¢–†–ï–ë–£–ï–¢–°–Ø 2FA –¥–ª—è {phone}")
                    return {
                        'success': True,
                        'message': '–¢—Ä–µ–±—É–µ—Ç—Å—è –ø–∞—Ä–æ–ª—å –¥–≤—É—Ö—Ñ–∞–∫—Ç–æ—Ä–Ω–æ–π –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏',
                        'needs_password': True
                    }
                
            except Exception as e:
                print(f"‚ùå –û–®–ò–ë–ö–ê –ü–†–û–í–ï–†–ö–ò –ö–û–î–ê: {e}")
                print(f"‚ùå TRACEBACK: {traceback.format_exc()}")
                return {'success': False, 'error': str(e)}
        
        result = run_async_in_global_loop(verify_code_async())
        print(f"üéØ –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–¥–∞: {json.dumps(result, indent=2)}")
        return jsonify(result)
        
    except Exception as e:
        print(f"üí• –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê –≤ verify_code: {str(e)}")
        print(f"üí• TRACEBACK: {traceback.format_exc()}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/auth/password', methods=['POST'])
@login_required
def check_password():
    try:
        print("üì• –ü–æ–ª—É—á–µ–Ω –∑–∞–ø—Ä–æ—Å –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É –ø–∞—Ä–æ–ª—è 2FA")
        data = request.get_json()
        phone = data.get('phone')
        password = data.get('password')
        operator = data.get('operator')
        
        if not all([phone, password, operator]):
            return jsonify({'success': False, 'error': 'All fields are required'})
        
        print(f"üõ°Ô∏è –ü–†–û–í–ï–†–ö–ê 2FA –¥–ª—è {phone}")
        
        async def check_password_async():
            try:
                client = await get_or_create_client(operator, phone)
                
                print(f"üöÄ –ü–†–û–í–ï–†–Ø–ï–ú –ü–ê–†–û–õ–¨ —á–µ—Ä–µ–∑ Telegram API...")
                
                user = await client.sign_in(password=password)
                print(f"‚úÖ 2FA –ü–†–ò–ù–Ø–¢ –¥–ª—è {phone}")
                
                # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Å–µ—Å—Å–∏–∏
                session_data = client.session.save()
                
                return {
                    'success': True,
                    'message': '–£—Å–ø–µ—à–Ω–∞—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è',
                    'session_data': session_data
                }
                
            except Exception as e:
                print(f"‚ùå –û–®–ò–ë–ö–ê –ü–†–û–í–ï–†–ö–ò 2FA: {e}")
                print(f"‚ùå TRACEBACK: {traceback.format_exc()}")
                return {'success': False, 'error': str(e)}
        
        result = run_async_in_global_loop(check_password_async())
        return jsonify(result)
        
    except Exception as e:
        print(f"üí• –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê –≤ check_password: {str(e)}")
        print(f"üí• TRACEBACK: {traceback.format_exc()}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/operators', methods=['GET'])
@login_required
def get_operators():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤ (–∞–¥–º–∏–Ω - –≤—Å–µ, –æ–ø–µ—Ä–∞—Ç–æ—Ä - —Ç–æ–ª—å–∫–æ —Å–≤–æ–π)"""
    if current_user.is_admin():
        operators = load_operators_safe()
        return jsonify({'operators': operators})
    else:
        # –û–ø–µ—Ä–∞—Ç–æ—Ä –≤–∏–¥–∏—Ç —Ç–æ–ª—å–∫–æ —Å–µ–±—è
        if current_user.assigned_operator_name:
            return jsonify({'operators': [current_user.assigned_operator_name]})
        else:
            return jsonify({'operators': []})

@app.route('/api/operators', methods=['POST'])
@admin_required
def add_operator():
    data = request.get_json()
    operator = data.get('operator')
    
    operators = load_operators_safe()
    if operator and operator not in operators:
        operators.append(operator)
        if save_operators_safe(operators):
            return jsonify({'success': True, 'operators': operators})
        else:
            return jsonify({'success': False, 'error': 'Failed to save operator'})
    return jsonify({'success': False, 'error': 'Operator already exists or invalid'})

@app.route('/api/operators/<operator>', methods=['DELETE'])
@admin_required
def delete_operator(operator):
    operators = load_operators_safe()
    original_count = len(operators)
    operators = [op for op in operators if op != operator]
    
    if len(operators) < original_count:
        if save_operators_safe(operators):
            return jsonify({'success': True, 'operators': operators})
        else:
            return jsonify({'success': False, 'error': 'Failed to delete operator'})
    else:
        return jsonify({'success': False, 'error': 'Operator not found'})

@app.route('/api/chats/<operator>', methods=['GET'])
@login_required
def get_chats(operator):
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞
        if not check_operator_access(operator):
            return jsonify({'success': False, 'error': '–î–æ—Å—Ç—É–ø –∫ —ç—Ç–æ–º—É –æ–ø–µ—Ä–∞—Ç–æ—Ä—É –∑–∞–ø—Ä–µ—â–µ–Ω'}), 403
        
        phone = request.args.get('phone')
        if not phone:
            return jsonify({'success': False, 'error': 'Phone number is required'})
        
        print(f"üî• –ó–ê–ì–†–£–ó–ö–ê –ß–ê–¢–û–í –¥–ª—è {operator} —Å —Ç–µ–ª–µ—Ñ–æ–Ω–æ–º {phone}")
        
        async def get_chats_async():
            try:
                client = await get_or_create_client(operator, phone)
                
                print("üöÄ –ó–ê–ì–†–£–ó–ö–ê –î–ò–ê–õ–û–ì–û–í...")
                
                all_dialogs = []
                dialog_count = 0
                today = date.today()
                today_start = datetime.combine(today, datetime.min.time()).replace(tzinfo=timezone.utc)
                
                async for dialog in client.iter_dialogs():
                    dialog_count += 1
                    all_dialogs.append(dialog)
                    
                    if dialog_count % 50 == 0:
                        await asyncio.sleep(0.05)
                
                print(f"‚úÖ –ó–ê–ì–†–£–ñ–ï–ù–û {len(all_dialogs)} –¥–∏–∞–ª–æ–≥–æ–≤")
                
                chats = []
                total_today_incoming = 0
                
                for dialog in all_dialogs:
                    try:
                        if (hasattr(dialog.entity, 'bot') and dialog.entity.bot) or \
                           dialog.entity.__class__.__name__ == 'UserEmpty':
                            continue
                        
                        last_message = ''
                        message_time = ''
                        today_incoming_count = 0
                        
                        if dialog.message:
                            if hasattr(dialog.message, 'message') and dialog.message.message:
                                last_message = dialog.message.message
                            elif hasattr(dialog.message, 'media'):
                                last_message = '–ú–µ–¥–∏–∞ —Ñ–∞–π–ª'
                            else:
                                last_message = '–°–æ–æ–±—â–µ–Ω–∏–µ'
                            
                            # –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
                            if hasattr(dialog.message, 'date') and dialog.message.date:
                                msg_date = dialog.message.date
                                if msg_date.date() == today:
                                    message_time = msg_date.strftime('%H:%M')
                                else:
                                    message_time = msg_date.strftime('%d.%m')
                        
                        # –ü–æ–¥—Å—á–µ—Ç –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –∑–∞ —Å–µ–≥–æ–¥–Ω—è
                        try:
                            async for msg in client.iter_messages(dialog.id, limit=50):
                                if msg.date and msg.date >= today_start:
                                    if not msg.out:  # –í—Ö–æ–¥—è—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                                        today_incoming_count += 1
                                else:
                                    break  # –°–æ–æ–±—â–µ–Ω–∏—è —Å—Ç–∞—Ä—à–µ —Å–µ–≥–æ–¥–Ω—è—à–Ω–µ–≥–æ –¥–Ω—è
                        except Exception as e:
                            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø–æ–¥—Å—á–µ—Ç–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è {dialog.id}: {e}")
                        
                        total_today_incoming += today_incoming_count
                        
                        unread_count = getattr(dialog, 'unread_count', 0)
                        
                        name = ""
                        try:
                            if hasattr(dialog.entity, 'first_name') and dialog.entity.first_name:
                                name += dialog.entity.first_name
                            if hasattr(dialog.entity, 'last_name') and dialog.entity.last_name:
                                if name:
                                    name += " "
                                name += dialog.entity.last_name
                            if not name and hasattr(dialog.entity, 'title') and dialog.entity.title:
                                name = dialog.entity.title
                            if not name:
                                name = f"–ß–∞—Ç {dialog.id}"
                        except Exception as e:
                            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–º–µ–Ω–∏ –¥–ª—è {dialog.id}: {e}")
                            name = f"–ß–∞—Ç {dialog.id}"
                        
                        chat_info = {
                            'id': str(dialog.id),
                            'name': name,
                            'lastMessage': last_message[:100] + '...' if len(last_message) > 100 else last_message,
                            'timestamp': message_time,
                            'unreadCount': unread_count,
                            'todayIncoming': today_incoming_count,
                            'type': 'group' if hasattr(dialog.entity, 'megagroup') or hasattr(dialog.entity, 'broadcast') else 'private'
                        }
                        chats.append(chat_info)
                        
                    except Exception as e:
                        print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∏–∞–ª–æ–≥–∞ {dialog.id}: {e}")
                        continue
                
                print(f"üéØ –ó–ê–ì–†–£–ñ–ï–ù–û {len(chats)} –ß–ê–¢–û–í")
                print(f"üìä –í–°–ï–ì–û –í–•–û–î–Ø–©–ò–• –ó–ê –°–ï–ì–û–î–ù–Ø: {total_today_incoming}")
                
                return {
                    'success': True, 
                    'chats': chats,
                    'todayStats': {
                        'totalIncoming': total_today_incoming,
                        'accountPhone': phone
                    }
                }
                
            except Exception as e:
                print(f"‚ùå –û–®–ò–ë–ö–ê –ó–ê–ì–†–£–ó–ö–ò –ß–ê–¢–û–í: {e}")
                return {'success': False, 'error': str(e)}
        
        result = run_async_in_global_loop(get_chats_async())
        return jsonify(result)
        
    except Exception as e:
        print(f"üí• –û–®–ò–ë–ö–ê: {str(e)}")
        return jsonify({
            'success': False, 
            'error': f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —á–∞—Ç–æ–≤: {str(e)}'
        }), 500

@app.route('/api/messages/<operator>/<chat_id>', methods=['GET'])
@login_required
def get_messages(operator, chat_id):
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞
        if not check_operator_access(operator):
            return jsonify({'success': False, 'error': '–î–æ—Å—Ç—É–ø –∫ —ç—Ç–æ–º—É –æ–ø–µ—Ä–∞—Ç–æ—Ä—É –∑–∞–ø—Ä–µ—â–µ–Ω'}), 403
        
        chat_id = int(chat_id)
        phone = request.args.get('phone')
        if not phone:
            return jsonify({'success': False, 'error': 'Phone number is required'})
        
        print(f"üî• –ó–ê–ì–†–£–ó–ö–ê –°–û–û–ë–©–ï–ù–ò–ô –¥–ª—è —á–∞—Ç–∞ {chat_id}")
        
        async def get_messages_async():
            try:
                client = await get_or_create_client(operator, phone)
                
                print("üöÄ –ó–ê–ì–†–£–ó–ö–ê –°–û–û–ë–©–ï–ù–ò–ô...")
                
                messages = []
                message_count = 0
                
                async for msg in client.iter_messages(chat_id, reverse=True):
                    try:
                        message_count += 1
                        
                        if message_count % 100 == 0:
                            await asyncio.sleep(0.02)
                        
                        message_text = ''
                        message_type = 'text'
                        voice_data = None
                        
                        if msg.message:
                            message_text = msg.message
                        elif msg.media:
                            if hasattr(msg.media, 'document'):
                                doc = msg.media.document
                                if doc and hasattr(doc, 'mime_type'):
                                    if 'audio/ogg' in doc.mime_type or 'audio/mpeg' in doc.mime_type:
                                        message_type = 'voice'
                                        message_text = '–ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ'
                                        duration = 0
                                        if hasattr(doc, 'attributes'):
                                            for attr in doc.attributes:
                                                if hasattr(attr, 'duration'):
                                                    duration = attr.duration
                                                    break
                                        voice_data = {
                                            'voiceDuration': f"0:{duration//60:02d}:{duration%60:02d}" if duration > 0 else "0:00",
                                            'voiceUrl': f"voice_{msg.id}.ogg"
                                        }
                                    else:
                                        message_text = '–î–æ–∫—É–º–µ–Ω—Ç'
                                else:
                                    message_text = '–§–∞–π–ª'
                            elif hasattr(msg.media, 'photo'):
                                message_text = '–§–æ—Ç–æ'
                            else:
                                message_text = '–ú–µ–¥–∏–∞'
                        else:
                            message_text = '–°–∏—Å—Ç–µ–º–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ'
                        
                        message_data = {
                            'id': str(msg.id),
                            'text': message_text,
                            'timestamp': msg.date.strftime('%H:%M') if hasattr(msg, 'date') and msg.date else '',
                            'isIncoming': not msg.out,
                            'isRead': True,
                            'type': message_type,
                            'sender': '–í—ã' if msg.out else '–°–æ–±–µ—Å–µ–¥–Ω–∏–∫'
                        }
                        
                        if voice_data:
                            message_data.update(voice_data)
                        
                        messages.append(message_data)
                        
                    except Exception as e:
                        print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è {msg.id}: {e}")
                        continue
                
                print(f"üéØ –ó–ê–ì–†–£–ñ–ï–ù–û {len(messages)} –°–û–û–ë–©–ï–ù–ò–ô")
                return {'success': True, 'messages': messages, 'chatTitle': f'–ß–∞—Ç {chat_id}'}
                
            except Exception as e:
                print(f"‚ùå –û–®–ò–ë–ö–ê –ó–ê–ì–†–£–ó–ö–ò –°–û–û–ë–©–ï–ù–ò–ô: {e}")
                return {'success': False, 'error': str(e)}
        
        result = run_async_in_global_loop(get_messages_async())
        return jsonify(result)
        
    except Exception as e:
        print(f"üí• –û–®–ò–ë–ö–ê: {str(e)}")
        return jsonify({
            'success': False, 
            'error': f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π: {str(e)}'
        }), 500

def create_admin_user():
    """–°–æ–∑–¥–∞–µ—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é"""
    with app.app_context():
        admin = User.query.filter_by(username='admin').first()
        if not admin:
            admin = User(
                username='admin',
                role='admin',
                assigned_operator_name='admin'
            )
            admin.set_password('admin123')
            db.session.add(admin)
            db.session.commit()
            print("‚úÖ –°–û–ó–î–ê–ù –ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–û–† –ü–û –£–ú–û–õ–ß–ê–ù–ò–Æ: admin/admin123")

if __name__ == '__main__':
    # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π event loop –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º Flask
    setup_global_event_loop()
    
    # –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—ã –∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
    with app.app_context():
        db.create_all()
        create_admin_user()
    
    port = int(os.environ.get('PORT', 5000))
    print(f"üöÄ Starting Flask app on port {port}")
    print(f"‚úÖ –ì–õ–û–ë–ê–õ–¨–ù–´–ô –ü–£–õ –ö–õ–ò–ï–ù–¢–û–í –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù!")
    print(f"üîÑ ASYNCIO EVENT LOOP –ò–°–ü–†–ê–í–õ–ï–ù!")
    print(f"üì° –ù–ï–ü–†–ï–†–´–í–ù–´–ô –ú–û–ù–ò–¢–û–†–ò–ù–ì –î–û–°–¢–£–ü–ï–ù!")
    print(f"üîê –°–ò–°–¢–ï–ú–ê –ê–í–¢–û–†–ò–ó–ê–¶–ò–ò –ê–ö–¢–ò–í–ù–ê!")
    print(f"üë§ –ê–î–ú–ò–ù –ü–û –£–ú–û–õ–ß–ê–ù–ò–Æ: admin/admin123")
    print(f"üìã Available routes:")
    for rule in app.url_map.iter_rules():
        print(f"  {rule.methods} {rule.rule}")
    
    app.run(host='0.0.0.0', port=port, debug=False)
